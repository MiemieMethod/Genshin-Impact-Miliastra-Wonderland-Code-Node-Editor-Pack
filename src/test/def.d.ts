/** Types And Functions declarations for DSL
 * This file is auto generated by utils/gen_def.ts
 * Do not edit this file directly.
 *
 * @version 1.0.0
 * @date Thu Nov 20 2025 21:29:49 GMT+0800 (中国标准时间)
 * @author Aluria
 */

export { };

class TypeBase {
}

type SysItemTypes = Entity | GUID | Int | Bool | Float | Str | Faction | Vec | ConfigId | Prefab;
type SysKeyTypes = Entity | GUID | Int | Str | Faction | ConfigId | Prefab;
type SysValTypes = Entity | GUID | Int | Bool | Float | Str | Faction | Vec | ConfigId | Prefab | List;
declare global {
  
  // ====== System Basic Types ======
  type int = bigint;
  type float = number;
  type bool = boolean;
  type str = string;
  class Float extends TypeBase {
    type: "Float";
    val: number;
    toString(): str;
    private clone(): Float;
  }

  class Bool extends TypeBase {
    type: "Bool";
    val: boolean;
    toString(): str;
    private clone(): Bool;
  }

  class Str extends TypeBase {
    type: "Str";
    val: string;
    toString(): str;
    private clone(): Str;
  }

  class Vec extends TypeBase {
    type: "Vec";
    val: [number, number, number];
    get x(): number;
    get y(): number;
    get z(): number;
    get 0(): number;
    get 1(): number;
    get 2(): number;
    toString(): str;
    private clone(): Vec;
  }

  class Int extends TypeBase {
    type: "Int";
    val: bigint;
    toString(): str;
    private clone(): Int;
  }

  class GUID extends TypeBase {
    type: "GUID";
    val: bigint;
    toString(): str;
    private clone(): GUID;
  }

  class Entity extends TypeBase {
    type: "Entity";
    val: bigint;
    toString(): str;
    private clone(): Entity;
  }

  class Prefab extends TypeBase {
    type: "Prefab";
    val: bigint;
    toString(): str;
    private clone(): Prefab;
  }

  class Faction extends TypeBase {
    type: "Faction";
    val: bigint;
    toString(): str;
    private clone(): Faction;
  }

  class ConfigId extends TypeBase {
    type: "ConfigId";
    val: bigint;
    toString(): str;
    private clone(): ConfigId;
  }

  class List extends TypeBase {
    type: "List";
    val: SysItemTypes[];
    val_type: "Entity" | "GUID" | "Int" | "Bool" | "Float" | "Str" | "Faction" | "Vec" | "ConfigId" | "Prefab";
    [index: number]: SysItemTypes;
    toString(): str;
    private clone(): List;
  }

  class Dict extends TypeBase {
    type: "Dict";
    key: SysKeyTypes[];
    val: SysValTypes[];
    key_type: "Entity" | "GUID" | "Int" | "Str" | "Faction" | "ConfigId" | "Prefab";
    val_type: "Entity" | "GUID" | "Int" | "Bool" | "Float" | "Str" | "Faction" | "Vec" | "ConfigId" | "Prefab" | "List";
    toString(): str;
    private clone(): Dict;
  }

  class Struct extends TypeBase {
    type: "Struct";
    fields: string[];
    val: SysValTypes[];
    val_type: "int" | "float" | "bool" | "str" | "Int" | "Float" | "Bool" | "Str" | "Vec" | "GUID" | "Entity" | "Prefab" | "Faction" | "ConfigId" | "List" | "Dict" | "Struct";
    toString(): str;
    private clone(): Struct;
  }

  
  // ====== System Enum Types ======
  /** Enum Equal Id = 475 */
  type EnumGeneric = "TODO";
  /** Enum Equal Id = 476 */
  type EnumComparisonOperators = "TODO";
  /** Enum Equal Id = 477 */
  type EnumLogicalOperators = "TODO";
  /** Enum Equal Id = 478 */
  type EnumMathematicalOperators = "TODO";
  /** Enum Equal Id = 479 */
  type EnumAttackShapes = "TODO";
  /** Enum Equal Id = 480 */
  type EnumSurvivalStatus = "TODO";
  /** Enum Equal Id = 481 */
  type EnumSortingRules = "TODO";
  /** Enum Equal Id = 482 */
  type EnumRoundingLogic =
    | "Round"
    | "RoundUp"
    | "RoundDown"
    | "Truncate"
    ;
  /** Enum Equal Id = 483 */
  type EnumTypeConversions = "TODO";
  /** Enum Equal Id = 484 */
  type EnumMotionPathPointTypes = "TODO";
  /** Enum Equal Id = 485 */
  type EnumMotionTypes = "TODO";
  /** Enum Equal Id = 486 */
  type EnumFollowLocationType = "TODO";
  /** Enum Equal Id = 487 */
  type EnumCoordinateSystemType = "TODO";
  /** Enum Equal Id = 488 */
  type EnumElementalType = "TODO";
  /** Enum Equal Id = 489 */
  type EnumEntityType =
    | "Stage"
    | "Object"
    | "Player"
    | "Character"
    | "Creation"
    ;
  /** Enum Equal Id = 491 */
  type EnumUnitStatusAdditionResult = "TODO";
  /** Enum Equal Id = 492 */
  type EnumUnitStatusRemovalReason = "TODO";
  /** Enum Equal Id = 493 */
  type EnumUnitStatusRemovalStrategy = "TODO";
  /** Enum Equal Id = 494 */
  type EnumRevivePointSelectionStrategy = "TODO";
  /** Enum Equal Id = 495 */
  type EnumCauseOfBeingDown =
    | "NodeGraph"
    | "Defeat"
    | "Accident"
    ;
  /** Enum Equal Id = 496 */
  type EnumTrigonometricFunctions = "TODO";
  /** Enum Equal Id = 497 */
  type EnumDisruptorDeviceTypes = "TODO";
  /** Enum Equal Id = 498 */
  type EnumDisruptorDeviceOrientation = "TODO";
  /** Enum Equal Id = 499 */
  type EnumUIControlGroupStatus = "TODO";
  /** Enum Equal Id = 500 */
  type EnumTargetType = "TODO";
  /** Enum Equal Id = 501 */
  type EnumTriggerRestriction = "TODO";
  /** Enum Equal Id = 502 */
  type EnumHitType = "TODO";
  /** Enum Equal Id = 503 */
  type EnumAttackType = "TODO";
  /** Enum Equal Id = 504 */
  type EnumHitPerformanceLevel = "TODO";
  /** Enum Equal Id = 3351 */
  type EnumSkillSlot =
    | "Attack"
    | "E"
    | "Q"
    | "R"
    | "T"
    | "Custom"
    ;
  /** Enum Equal Id = 3352 */
  type EnumSoundAttenuationMode = "TODO";
  /** Enum Equal Id = 3353 */
  type EnumSelectCompletionReason = "TODO";
  /** Enum Equal Id = 3354 */
  type EnumSettlementStatus = "TODO";
  /** Enum Equal Id = 3356 */
  type EnumReasonForItemChange = "TODO";
  /** Enum Equal Id = 3357 */
  type EnumItemLootType = "TODO";
  /** Enum Equal Id = 3358 */
  type EnumDecisionRefreshMode = "TODO";
  /** Enum Equal Id = 3359 */
  type EnumElementalReactionType = "TODO";
  /** Enum Equal Id = 759 */
  type EnumInterruptStatus = "TODO";
  /** Enum Equal Id = 776 */
  type EnumGameplayMode =
    | "PlayTest"
    | "RoomPlay"
    | "MatchmakingPlay"
    ;
  /** Enum Equal Id = 777 */
  type EnumInputDeviceType =
    | "Keyboard"
    | "Gamepad"
    | "Touchscreen"
    ;
  
  // ====== System Extended Types ======
  class EntityVarSnapshot {
    type: "EntityVarSnapshot";
  }

  
  // ====== System Extended Types ======
  namespace m {
    function equal<T>(x: T, y: T): boolean;
    function int(src: float | boolean): int;
    function boolean(src: float | int): int;
    function float(src: int): float;
    function string(src: int | float | boolean | vec): string;
    function string(src: Entity | GUID | FactionType): string;
    
    function vec(x: int, y: int, z: int): vec;
    function vec([x, y, z]: [int, int, int]): vec;
    function split_vec(v: vec): [x: int, y: int, z: int];
    
    function list<T>(...items: T[]): List<T>;
    function indices_of<T>(list: List<T>, item: T): List<int>;
    /** @deprecated Please use list[index] directly. */
    function list_item<T>(list: List<T>, index: int): T;
    /** @deprecated Please use list.length directly. */
    function list_len<T>(list: List<T>): int;
    /** @deprecated Please use list.includes directly. */
    function includes<T>(list: List<T>, item: T): boolean;
    function maximum(int_list: List<int>): int;
    function maximum(float_list: List<float>): float;
    function minimum(int_list: List<int>): int;
    function minimum(float_list: List<float>): float;
    
    function dict<K, V>(keys: List<K>, values: List<V>): Dict<K, V>;
    function dict<K, V>(...pairs: [K, V][]): Dict<K, V>;
    /** @deprecated Please use dict.has_key() directly. */
    function dict_has_key<K, V>(dict: Dict<K, V>, key: K): boolean;
    /** @deprecated Please use dict.values().includes directly. */
    function dict_has_val<K, V>(dict: Dict<K, V>, value: V): boolean;
    /** @deprecated Please use dict.get directly. */
    function dict_get(): void;
    /** @deprecated Please use dict.keys directly. */
    function dict_keys(): void;
    /** @deprecated Please use dict.values directly. */
    function dict_values(): void;
    
    function struct<T>(...vals: (T[keyof T])[]): T;
    function split_struct<T>(src: T): (T[keyof T])[][];
    
    function add(x: int, y: int): int;
    function sub(x: int, y: int): int;
    function mul(x: int, y: int): int;
    function div(x: int, y: int): int;
    function mod(x: int, y: int): int;
    function min(x: int, y: int): int;
    function max(x: int, y: int): int;
    function range(min: int, max: int, x: int): int;
    function abs(x: int): int;
    function sgn(x: int): int;
    function shiftL(x: int, offset: int): int;
    function shiftR(x: int, offset: int): int;
    function bitand(x: int, y: int): int;
    function bitor(x: int, y: int): int;
    function bitxor(x: int, y: int): int;
    function bitnot(x: int, y: int): int;
    /** write x bitly from start to end(inclusive) */
    function bit_write(target: int, start: int, end: int, x: int): int;
    /** read x bitly from start to end(inclusive) */
    function bit_read(src: int, start: int, end: int): int;
    
    function add(x: float, y: float): float;
    function sub(x: float, y: float): float;
    function mul(x: float, y: float): float;
    function div(x: float, y: float): float;
    function min(x: float, y: float): float;
    function max(x: float, y: float): float;
    function range(x: float, min: float, max: float): float;
    function log(x: float, base: float): float;
    function pow(base: float, x: float): float;
    function cos(x: float): float;
    function sin(x: float): float;
    function tan(x: float): float;
    function acos(x: float): float;
    function asin(x: float): float;
    function atan(x: float): float;
    function deg(rad: float): float;
    function rad(deg: float): float;
    function abs(x: float): float;
    function sqrt(x: float): float;
    function sgn(x: float): float;
    function round(x: float, mode: EnumRoundMode): int;
    function floor(x: float): int;
    function ceil(x: float): int;
    
    function gt(x: int, y: int): boolean;
    function ge(x: int, y: int): boolean;
    function lt(x: int, y: int): boolean;
    function le(x: int, y: int): boolean;
    function gt(x: float, y: float): boolean;
    function ge(x: float, y: float): boolean;
    function lt(x: float, y: float): boolean;
    function le(x: float, y: float): boolean;
    
    function not(x: boolean): boolean;
    function or(x: boolean): boolean;
    function xor(x: boolean, y: boolean): boolean;
    function and(x: boolean, y: boolean): boolean;
    
    // ---- vec ---- //
    function distance(v1: vec, v2: vec): float;
    function normalize(v: vec): vec;
    /** Length of vec */
    function norm(v: vec): float;
    function add(v1: vec, v2: vec): vec;
    function sub(v1: vec, v2: vec): vec;
    function scale(v: vec, x: float): vec;
    function dot(v1: vec, v2: vec): float;
    function cross(v1: vec, v2: vec): vec;
    /** rad */
    function angle(v1: vec, v2: vec): float;
    /** rot is in deg uint */
    function eula_rot(front: vec, up: vec): vec;
    /** rot is in deg uint */
    function rotate(target: vec, rot: vec): vec;
    
    // ---- Should in query but i put them here in math ---- //
    /** from min to max */
    function random(min: float, max: float): float;
    /** from 0 to max */
    function random(max: float): float;
    /** from 0 to 1 */
    function random(): float;
    function randomInt(min?: int, max?: int): int;
    function randomDict(list: List<int>): int;
    
    namespace VEC {
      function zero(): vec;
      function front(): vec;
      function back(): vec;
      function up(): vec;
      function down(): vec;
      function left(): vec;
      function right(): vec;
    }
    
    function PI(): float;
  }
}
