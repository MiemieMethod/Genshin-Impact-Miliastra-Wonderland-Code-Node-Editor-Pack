/** Types declaration for protobuf
 * This file is auto generated by utils/protobuf/proto2ts.ts
 * Do not edit this file directly.
 *
 * @version 1.0.3
 * @date Fri Nov 21 2025 20:43:53 GMT+0800 (中国标准时间)
 * @author Aluria
 * 
 * @source D:\Program\JS\GI\Convertor\utils\protobuf/gia.proto
 * @dest D:/Program/JS/GI/Convertor/utils/protobuf/gia.proto.ts
 * @program file:///D:/Program/JS/GI/Convertor/utils/protobuf/proto2ts.ts
 */

import {
  NodeUnit$Id$Type,
  NodeUnit$Id$NodeType,
  NodeUnit$Type,
  CompositeDef$Type$Kind,
  NodeGraph$Id$Class,
  NodeGraph$Id$Type,
  NodeGraph$Id$Kind,
  VarType,
  VarBase$Class,
  VarBase$ItemType$Inner$Kind,
  NodeProperty$Type,
  NodePin$Index$Kind,

} from "./gia.proto.ts";

declare interface Root {
  graph: NodeUnit; // 1
  utils: NodeUnit[]; // 2
  filePath: string; // 3
}
declare interface NodeUnit {
  id: NodeUnit$Id; // 1
  relatedIds: NodeUnit$Id[]; // 2
  name: string; // 3
  type: NodeUnit$Type; // 5
  /** One of the field: graphType */
  graph?: NodeGraphWrapper; // 13
  /** One of the field: graphType */
  compositeDef?: CompositeDefWrapper; // 14
  /** One of the field: graphType */
  structureDef?: StructureDefWrapper; // 22
}
declare interface NodeUnit$Id {
  type: NodeUnit$Id$Type; // 2
  kind?: NodeUnit$Id$NodeType; // 3
  id: number; // 4
}
declare type NodeUnit$Id$Type = (typeof NodeUnit$Id$Type)[keyof typeof NodeUnit$Id$Type];
declare type NodeUnit$Id$NodeType = (typeof NodeUnit$Id$NodeType)[keyof typeof NodeUnit$Id$NodeType];
declare type NodeUnit$Type = (typeof NodeUnit$Type)[keyof typeof NodeUnit$Type];
declare interface NodeGraphWrapper {
  inner: NodeGraphWrapper$InnerWrapper; // 1
}
declare interface NodeGraphWrapper$InnerWrapper {
  graph: NodeGraph; // 1
}
declare interface CompositeDefWrapper {
  inner: CompositeDefWrapper$InnerWrapper; // 1
}
declare interface CompositeDefWrapper$InnerWrapper {
  def: CompositeDef; // 1
}
declare interface CompositeDef {
  id: CompositeDef$Id; // 4
  inflows: CompositeDef$ControlFlow[]; // 100
  outflows: CompositeDef$ControlFlow[]; // 101
  inputs: CompositeDef$ParameterFlow[]; // 102
  outputs: CompositeDef$ParameterFlow[]; // 103
  type: CompositeDef$Type; // 107
  name: string; // 200
  description: string; // 201
}
declare interface CompositeDef$Id {
  genericId: NodeGraph$Id; // 1
  concreteId: NodeGraph$Id; // 2
  graphId: NodeGraph$Id; // 4
}
declare interface CompositeDef$ParameterFlow {
  name: string; // 1
  visible: boolean; // 2
  index: NodePin$Index; // 3
  type: CompositeDef$ParameterFlow$Type; // 4
  pinIndex: number; // 8
}
declare interface CompositeDef$ParameterFlow$Type {
  class: VarBase$Class; // 1
  type1: VarType; // 3
  type2: VarType; // 4
  /** One of the field: type */
  mapType?: CompositeDef$ParameterFlow$Type$MapType; // 105
  valueId: CompositeDef$ParameterFlow$Type$ID; // 104
}
declare interface CompositeDef$ParameterFlow$Type$MapType {
  key: VarType; // 3
  value: VarType; // 4
}
declare interface CompositeDef$ParameterFlow$Type$ID {
  id: number; // 2
}
declare interface CompositeDef$ControlFlow {
  name: string; // 1
  visible: boolean; // 2
  index: NodePin$Index; // 3
  description: string; // 4
  pinIndex: number; // 8
}
declare interface CompositeDef$Type {
  kind: CompositeDef$Type$Kind; // 1
  /** One of the field: parent */
  assemble?: CompositeDef$Type$Id; // 104
  /** One of the field: parent */
  split?: CompositeDef$Type$Id; // 105
  /** One of the field: parent */
  modify?: CompositeDef$Type$Id; // 106
}
declare type CompositeDef$Type$Kind = (typeof CompositeDef$Type$Kind)[keyof typeof CompositeDef$Type$Kind];
declare interface CompositeDef$Type$Id {
  id: number; // 1
}
declare interface NodeGraph {
  id: NodeGraph$Id; // 1
  name: string; // 2
  nodes: GraphNode[]; // 3
  compositePins: CompositePin[]; // 4
  graphValues: GraphVariable[]; // 6
  affiliations: GraphAffiliation[]; // 7
}
declare interface NodeGraph$Id {
  class: NodeGraph$Id$Class; // 1
  type: NodeGraph$Id$Type; // 2
  kind: NodeGraph$Id$Kind; // 3
  id: number; // 5
}
declare type NodeGraph$Id$Class = (typeof NodeGraph$Id$Class)[keyof typeof NodeGraph$Id$Class];
declare type NodeGraph$Id$Type = (typeof NodeGraph$Id$Type)[keyof typeof NodeGraph$Id$Type];
declare type NodeGraph$Id$Kind = (typeof NodeGraph$Id$Kind)[keyof typeof NodeGraph$Id$Kind];
declare interface GraphAffiliation {
  info: GraphAffiliation$Info; // 1
  type: GraphAffiliation$Type; // 2
}
declare interface GraphAffiliation$Info {
  source: NodeGraph$Id; // 1
  typeXxx: number; // 2
  alwaysOneXxxx: number; // 3
  /** One of the field: extend */
  structId?: VarBase$ItemType$StructItem; // 100
}
declare interface GraphAffiliation$Type {
  type: number; // 1
}
declare interface StructureDefWrapper {
  def: StructureDefWrapper$StructureDef; // 1
}
declare interface StructureDefWrapper$StructureDef {
  genericField: StructureDefWrapper$Field; // 1
  connectField: StructureDefWrapper$Field; // 2
  index: number; // 3
  itemCount: number; // 4
}
declare interface StructureDefWrapper$Field {
  id: number; // 1
  vars: StructureDefWrapper$VarDef[]; // 3
  structName: string; // 501
  classBase: number; // 502
  index: number; // 503
}
declare interface StructureDefWrapper$VarDef {
  id: StructureDefWrapper$VarDef$Id; // 1
  def: StructureDefWrapper$VarDef$Content; // 3
  name: string; // 5
  name2: string; // 501
  type: VarType; // 502
  index: number; // 503
}
declare interface StructureDefWrapper$VarDef$SubType {
  xxx: number; // 1
  xxxx: number; // 2
  key: VarType; // 502
  value: VarType; // 503
  valueId: number; // 504
}
declare interface StructureDefWrapper$VarDef$Id {
  type: VarType; // 1
  sub: StructureDefWrapper$VarDef$SubType; // 2
}
declare interface StructureDefWrapper$VarDef$Content {
  type: VarType; // 1
  sub: StructureDefWrapper$VarDef$SubType; // 2
  /** One of the field: val */
  intVal?: IntBaseValue; // 13
  /** One of the field: val */
  boolVal?: EnumBaseValue; // 14
  /** One of the field: val */
  strVal?: StringBaseValue; // 16
}
declare type VarType = (typeof VarType)[keyof typeof VarType];
declare interface GraphVariable {
  name: string; // 2
  type: VarType; // 3
  values: VarBase; // 4
  exposed: boolean; // 5
  structId: number; // 6
  keyType: VarType; // 7
  valueType: VarType; // 8
}
declare interface VarBase {
  class: VarBase$Class; // 1
  alreadySetVal: boolean; // 2
  itemType: VarBase$ItemType; // 4
  structInfo?: VarBase$StructInfo; // 5
  /** One of the field: baseValues */
  bId?: IdBaseValue; // 101
  /** One of the field: baseValues */
  bInt?: IntBaseValue; // 102
  /** One of the field: baseValues */
  bFloat?: FloatBaseValue; // 104
  /** One of the field: baseValues */
  bString?: StringBaseValue; // 105
  /** One of the field: baseValues */
  bEnum?: EnumBaseValue; // 106
  /** One of the field: baseValues */
  bVector?: VectorBaseValue; // 107
  /** One of the field: baseValues */
  bStruct?: StructBaseValue; // 108
  /** One of the field: baseValues */
  bArray?: ArrayBaseValue; // 109
  /** One of the field: baseValues */
  bNodeValue?: NodeValueBaseValue; // 110
  /** One of the field: baseValues */
  bMapPair?: MapPairBaseValue; // 111
  /** One of the field: baseValues */
  bMap?: MapBaseValue; // 112
}
declare type VarBase$Class = (typeof VarBase$Class)[keyof typeof VarBase$Class];
declare interface VarBase$ItemType {
  classBase: number; // 1
  itemType: VarBase$ItemType$Inner; // 100
}
declare interface VarBase$ItemType$StructItem {
  structId: number; // 1
}
declare interface VarBase$ItemType$Inner {
  type: VarType; // 1
  kind: VarBase$ItemType$Inner$Kind; // 2
  /** One of the field: id */
  item?: VarBase$ItemType$StructItem; // 100
  /** One of the field: id */
  items?: VarBase$ItemType$Inner$PairItems; // 101
}
declare type VarBase$ItemType$Inner$Kind = (typeof VarBase$ItemType$Inner$Kind)[keyof typeof VarBase$ItemType$Inner$Kind];
declare interface VarBase$ItemType$Inner$PairItems {
  key: VarType; // 1
  value: VarType; // 2
  structId: number; // 3
}
declare interface VarBase$StructInfo {
  xxx: number; // 1
  inner: VarBase$StructInfo$Inner; // 100
}
declare interface VarBase$StructInfo$Inner {
  xxx: number; // 1
}
declare interface IdBaseValue {
  val: number; // 1
}
declare interface IntBaseValue {
  val: number; // 1
}
declare interface FloatBaseValue {
  val: number; // 1
}
declare interface StringBaseValue {
  val: string; // 1
}
declare interface EnumBaseValue {
  val: number; // 1
}
declare interface VectorBaseValue {
  val: VectorBaseValue$Vec; // 1
}
declare interface VectorBaseValue$Vec {
  x: number; // 1
  y: number; // 2
  z: number; // 3
}
declare interface StructBaseValue {
  items: VarBase[]; // 1
}
declare interface ArrayBaseValue {
  entries: VarBase[]; // 1
}
declare interface MapBaseValue {
  mapPairs: VarBase[]; // 1
}
declare interface MapPairBaseValue {
  key: VarBase; // 1
  value: VarBase; // 2
}
declare interface NodeValueBaseValue {
  classBase: number; // 1
  value: VarBase; // 2
  wrapper: NodeValueBaseValue$Wrapper; // 5
}
declare interface NodeValueBaseValue$Wrapper {
  classBase: number; // 4
  inner: NodeValueBaseValue$Wrapper$Inner; // 100
}
declare interface NodeValueBaseValue$Wrapper$Inner {
  wrapper: NodeValueBaseValue$Wrapper$Inner$Wrapper; // 1
}
declare interface NodeValueBaseValue$Wrapper$Inner$Wrapper {
  class: VarBase$Class; // 1
  /** One of the field: type */
  item?: VarBase$ItemType$StructItem; // 100
}
declare interface GraphNode {
  nodeIndex: number; // 1
  genericId: NodeProperty; // 2
  concreteId: NodeProperty; // 3
  pins: NodePin[]; // 4
  x: number; // 5
  y: number; // 6
  usingStruct: GraphAffiliation$Info[]; // 10
}
declare interface NodeProperty {
  class: NodeGraph$Id$Class; // 1
  type: NodeProperty$Type; // 2
  kind: NodeGraph$Id$Kind; // 3
  nodeId: number; // 5
}
declare type NodeProperty$Type = (typeof NodeProperty$Type)[keyof typeof NodeProperty$Type];
declare interface NodePin {
  i1: NodePin$Index; // 1
  i2: NodePin$Index; // 2
  value: VarBase; // 3
  type: VarType; // 4
  connects: NodeConnection[]; // 5
}
declare interface NodePin$Index {
  kind: NodePin$Index$Kind; // 1
  index: number; // 2
}
declare type NodePin$Index$Kind = (typeof NodePin$Index$Kind)[keyof typeof NodePin$Index$Kind];
declare interface NodeConnection {
  id: number; // 1
  connect: NodePin$Index; // 2
  connect2: NodePin$Index; // 3
}
declare interface CompositePin {
  outerPin: NodePin$Index; // 1
  innerNodeId: number; // 2
  innerPin: NodePin$Index; // 3
  innerPin2: NodePin$Index; // 4
}
