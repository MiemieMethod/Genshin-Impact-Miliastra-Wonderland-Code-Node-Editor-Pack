# Protobuf Toolset (`utils/protobuf`)

This directory contains a complete toolchain for processing, reverse-engineering, and validating Protobuf data (specifically `.gia` files). This toolset is designed to balance **production environment efficiency** with **testing environment transparency**.

For a description of [gia.proto](./gia.proto), see the comments within and the [Legacy Node Graph System Architecture Reference](../../docs/utils/LegacyNodeGraphSystemArchitectureReference.en.md) in the docs. Unraveling the truth behind the real kernel and mechanisms through surface data structures.

---

## Core Components Overview

### 1. Structure Definition and Type Generation
*   **[`gia.proto`](./gia.proto)**: **Core Definition File**. Contains the complete Protobuf structure definition for GIA files. It serves as the system's "Source of Truth".
*   **[`gia.proto.ts`](./gia.proto.ts)**: **Automatically Generated Type Definitions**. Converts `.proto` into TypeScript interfaces via `proto2ts.ts` for global use.

### 2. Dual-Path Encoding/Decoding System
Two complementary decoding solutions are provided for different use cases:

| Feature | **[`decode.ts`](./decode.ts)** (Production/Forward) | **[`decode-cli.ts`](./decode-cli.ts)** (Debugging/Reverse) |
| :--- | :--- | :--- |
| **Underlying Library** | Uses standard `protobufjs` library | **Purely Manual Parsing** (based on `decode_raw.ts`) |
| **Primary Goal** | Performance, Consistency, Standard Compliance | **Visibility, Error Feedback, Structure Analysis** |
| **Core Logic** | Direct fast binary conversion based on definition | Heuristic search for sub-messages, strings, and byte streams |
| **Error Handling** | Usually reports errors directly or generates default values if data mismatches | Generates detailed `ValidationError` reports, preserves raw data |
| **Use Cases** | Automated conversion scripts, application runtime | Reverse-engineering new protocols, verifying `proto` modifications, data alignment |

---

## In-depth Analysis of Key Tools

### üîç `decode-cli.ts` & `decode_raw.ts` (Test-Driven)
This is the most critical reverse-engineering component of this toolset. Its workflow does not rely on `protobufjs`'s default decoding logic, but instead employs a strategy of "first parsing the binary structure, then comparing it against the definition".

*   **`decode_raw.ts` (Manual Parsing Core)**:
    - Recursively parses arbitrary Protobuf messages without needing any `.proto` file.
    - Automatically identifies `WireType` (Varint, Fixed32/64, Length-delimited).
    - **Heuristic Identification**: For `Length-delimited` fields, it attempts to recursively parse them as nested messages. If that fails, it tries to parse them as strings, finally falling back to raw bytes.
*   **`verify_proto.ts` (Structure Validator)**:
    - Compares the result of `decode_raw.ts` against the hierarchical structure generated by `proto2ts.ts`.
    - **Error Feedback**: Provides path-specific error messages such as `MISSING_FIELD` (missing required field), `EXTRA_FIELD` (undefined field), `TYPE_MISMATCH` (type mismatch), etc.
    - **Alignment & Reconstruction**: Reassembles the parsed anonymous data into a structured object based on field names.

### ‚ö° `decode.ts` (Production Tool)
Encapsulates the standard encoding/decoding process based on `protobufjs`.

*   **`unwrap_gia` / `wrap_gia`**: Handles GIA-specific file encapsulation format.
    - **GIA Header (20 bytes)**: Contains file size, version number (`0x01`), `Magic Tag` (`0x0326`), file type (`0x03`).
    - **GIA Footer (4 bytes)**: Contains checksum (`0x0679`).
*   **`decode_gia_file`**: Completes the process of "read file -> unwrap GIA encapsulation -> Protobuf deserialization -> convert to plain object" in one go.

### üõ†Ô∏è Other Auxiliary Tools
*   **`proto2ts.ts`**: A lightweight `Proto` parser. It reads `.proto` files without external dependencies and generates TypeScript interfaces with namespace support, as well as a message dictionary for `verify_proto.ts`.

---

## Typical Workflow

### 1. Verify if Modified Proto is Compatible with Binary Files
After modifying `gia.proto`, you can use the `CLI` tool to verify in test mode:
```bash
# Run CLI, load proto, decode, and output all validation errors
node utils/protobuf/decode-cli.ts <path_to_gia> --print-errors
```
If `EXTRA_FIELD` is found, it means the data contains fields you haven't defined; if `TYPE_MISMATCH`, then a field's type definition might be incorrect.

### 2. Reading and Writing Data in Production Environment
```typescript
import { decode_gia_file, encode_gia_file } from "./utils/protobuf/decode.ts";

// Decode
const bundle = decode_gia_file("input.gia");

// Modify
bundle.primary_resource.internal_name = "modified_name";

// Encode back
encode_gia_file("output.gia", bundle);
```

### 3. Generating New TS Type Definitions
```bash
node utils/protobuf/proto2ts.ts ./utils/protobuf/gia.proto.ts ./utils/protobuf/gia.proto
```

---

## Detailed File List

| File | Description | Key Methods/Functions |
| :--- | :--- | :--- |
| [`gia.proto`](./gia.proto) | Core Protobuf Definition | GIA file structure, resource location, and type system definitions |
| [`gia.proto.ts`](./gia.proto.ts) | Static Type Definitions | Automatically generated TypeScript interfaces for business logic type constraints |
| [`decode.ts`](./decode.ts) | Production Environment Encoding/Decoding | `decode_gia_file` / `encode_gia_file`: Standard GIA file read/write |
| [`decode-cli.ts`](./decode-cli.ts) | Reverse-Engineering Tool | Command-line interface, provides deep structure validation and error summarization |
| [`decode_raw.ts`](./decode_raw.ts) | Raw Protobuf Parsing | `ProtobufParser`: Recursively parses binary streams, infers data structure |
| [`proto2ts.ts`](./proto2ts.ts) | Protocol Converter | Parses `.proto` definitions into `TS` code and internal `TypeLayers` for validation |
| [`verify_proto.ts`](./verify_proto.ts) | Structure Validation & Reconstruction | `verifyProto`: Compares raw data with definition, reports inconsistencies, and reconstructs named structure |

## Detailed Usage

### 1. Raw Parsing and Validation Toolchain (`decode_raw.ts` & `verify_proto.ts`)
When you need to analyze unknown data structures or validate protocol modification compatibility.

```typescript
import { ProtobufParser } from "./decode_raw.ts";
import { verifyProto } from "./verify_proto.ts";
import { parse } from "./proto2ts.ts";

// 1. Raw parsing (extracts field IDs and data without definitions)
const parser = new ProtobufParser();
const { result: rawData } = parser.parseMessage(binaryPayload);

// 2. Load protocol definition
const layers = parse(protoContent);
const assetType = layers.message.get("AssetBundle");

// 3. Perform validation and reconstruction (maps field IDs to names and validates types)
const { errors, result: formattedData } = verifyProto(rawData, assetType!);

if (errors.length > 0) {
  console.warn("Found structural differences:", errors);
}
```

### 2. Command-Line Validation Tool (`decode-cli.ts`)
The most convenient debugging method, directly view comparison differences or export conversion results in the terminal.

```bash
# Basic usage: validate file structure and print errors
node utils/protobuf/decode-cli.ts input.gia --print-errors

# Filter specific path errors and export to JSON/JS file
node utils/protobuf/decode-cli.ts input.gia --skip-paths root.secondary --out debug_res.json

# Query usage
node utils/protobuf/decode-cli.ts -h
```

```log
Usage: node decode-cli.ts <input_path> [options]

Required Arguments:
  input_path                Path to .gia or protobuf binary file.

Options:
  -h, --help                Show this help message.
  -o, --out <path>          Output path for decoded JSON file (defaults to not saving to file).
  -p, --protobuf <path>     Protobuf file path (defaults to loading gia.proto).
  -m, --message <name>      Name of the Protobuf message to decode (default: Root).
  -q, --quiet               Disable all console output.
  -s, --strict <boolean>    Enable strict parsing (default: true).
  -n, --no-slice            Disable default slicing operation (20:-4) on input file.
  -e, --print-errors        Display all errors in error output.
  --missing-error           Display missing field errors in error output.
  --extra-error             Display extra field errors in error output.
  --type-error              Display type mismatch errors in error output.
  --repeated-error          Display repeated field mismatch errors in error output.
  --enum-error              Display invalid enum errors in error output.
  --skip-paths <paths>      List of error paths to skip (case-sensitive, prefix matching).
                            Multiple paths can be separated by spaces.
```