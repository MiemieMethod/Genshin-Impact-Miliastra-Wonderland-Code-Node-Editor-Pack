我们的最终目的不是给出一份可运行的代码, 而是猜测并整理原本节点图遗留系统的"屎山", 并给出一份清晰完善的文档, 说明各部分是什么结构与关系, 以及新系统的结构该是什么样的.


我重新整理了数据, 得到了新的信息:
子系统A是服务器运行的节点图, 子系统B是客户端中运行的节点图.
节点有两种: 纯运算节点, 包含控制流的执行节点.
子系统B中所有执行节点(似乎都需要改变服务器状态, 向服务器发送请求)的内核层id均为2000, 而运算节点(在本地就能完成)内核层id均不是2000. 但这带来了一个问题: 内核层调用时, 没有区分外壳层的类型(也就是调用的是哪个函数), 此外, 如果内核的函数接口是强类型的(否则为什么 Addition<Int>与Addition<Float>不合并), 为什么不同外壳函数绑定内核时, 在同一个引脚位置使用了不同类型的传入? (似乎2000并不是完全确定的一个内核, 更多信息见下面关于 Type 5 的说明)


对于待确认的问题与分歧点的回答:
1. 关于“隐藏节点 (Type 5)”的究竟是什么? 
从数据来看, 有且仅有子系统B的执行节点有一个该类型的引脚(且仅存在一个), 且两个次序编号均为0. 其结构与(类型为 int 且值为 0 的)数据输入引脚结构一致. 且该引脚不显示, 值始终为空. 该引脚数据中还有一个额外的字段, 内部值与节点的第一个id相同.(或许区分了究竟是哪个内核?)
特例(重要): 在节点图中, 有一个节点是 SendSignalToServer , 需要提前设置信号数据格式, 在输入框中提供名称, 自动出现对应的引脚. 从它导出的数据结构来看, 有三点特殊性: 输入框中输入名称的位置是 Type5 Index1(内外一致), 其余结构和普通数据输入引脚(字符串类型)一样, 这也是唯一一个对外可见的Type5(另外, 在定义消息结构后会动态生成一些如接收/转发的节点及动态 id, )




composite 定义分为两个部分: 外壳定义与内部结构定义.
外壳定义非常简单: 有哪些引脚, 是什么类型, 有什么名字, 并分配一个全局的 composite pin id (从1开始) **可以用来导出枚举的id和类型扩展**
内部结构定义包含基本的图结构, 并单独保存了对外的引脚列表(compositePins), 每一项均包含这些信息: 连接到了哪一个外壳引脚(组别和index), 内部连接的是哪个节点的哪个引脚(nodeIndex + pinType/Index of Shell and Kernel)

结构不能说很差吧, 反正不好.